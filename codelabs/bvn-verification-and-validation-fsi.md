summary: Performing BVN Verification and Validation using the NIBSS FSI Sandbox
id: bvn-verification-and-validation-fsi
categories: Web
tags: fsi-sandbox
status: Published
authors: Victor Akinyemi
feedback link: https://dscfuta.com

# Performing BVN Verification and Validation using the NIBSS FSI Sandbox

## Overview

Duration: 1

In this codelab, we shall be taking a look at how to perform actions such as BVN verification and validation using the FSI Sandbox API by constructing a wrapper API around it.

A live example of what we will build is available at: `https://dsc-fsi-wrapper.herokuapp.com/api`

Negative
: **N/B:** The sandbox API is restricted and only provides a simulation of what the actual API works like. Therefore, only data present in the sandbox can be used, this includes BVNs and user data.

### Resources

- [Documentation for the Wrapper API](https://documenter.getpostman.com/view/9936833/SWLce9RJ?version=latest)
- [FSI Sandbox](https://sandbox.fsi.ng)
- [Source code for the Wrapper API](https://github.com/tehlordvortex/dsc-fsi-wrapper)

## Project Setup

Duration: 5

For the purposes of this codelab, we will be using NodeJS and Express.js.

Create a folder for this project and cd into it:

```
$ mkdir fsi-codelab && cd fsi-codelab
```

Then initialize an npm project in the directory. We're accepting all default options here since they don't really matter.
We also install some dependencies, including `nodemon` to automatically restart the project when we make changes to our code, and `node-fetch`, an implementation of the `fetch` API for Node.

```
$ npm init -y && npm install --save express node-fetch && npm install --save-dev nodemon
```

Create a file called `index.js` and type (or copy-paste) the following inside:

```javascript
const app = require("express")();

app.get("/", function(req, res) {
  res.send("Hello World!");
});

app.listen(3000, function() {
  console.log(`App listening on *:3000`);
});
```

Then run `npx nodemon`, which will start our program and automatically restart it when we make any changes.

## How to communicate with the sandbox API

Duration: 10

### Introduction

In this section, you will learn how to communicate with the sandbox API. The API is mostly a normal RESTful API, with some additional requirements for security. Some additional headers are required, and requests are encrypted before sending them and decrypted once received. The keys for performing these operations are generated by the server in a process that is outlined below.

### Communicating with the API - Generating encryption keys

All categories of requests on the API (/bvnr for BVN verification, /BVNPlaceHolder for BVN matching, /fp for Fingerprint validation respectively) have an associated `/Reset` route that doesn't require an encrypted request body.

This `/Reset` route is used to generate the encryption keys which are then used henceforth for all requests to any other route in that category. The process is as follows:

* Make a request to /Reset with the following headers:
  - `OrganisationCode`: Your organisation code (`11111` in the case of the FSI Sandbox), in base64 encoded format.
  - `Sandbox-Key`: Your sandbox key, which can be gotten from your profile on the [FSI Sandbox](http://sandbox.fsi.ng).
* If the details are correct, a response with status 200 OK is returned with the following extra headers
  - `name`: The name of the organisation
  - `ivkey`: One of the pair of keys used in the encryption process
  - `aes_key`: One of the pair of keys used in the encryption process
  - `password`: This password will be used when generating some of the required headers
  - `email`: The email associated with the organisation
  - `code`: The organisation code
* We generate the required headers using the above details:
  - `OrganisationCode`: Same as before
  - `Sandbox-Key`: Same as before
  - `SIGNATURE`: This is a SHA256 hashed string that consists of the organisation code, concatenated with today's date in YYYYMMDD format, then concatenated with the password. Basically:

    ```javascript
    const SIGNATURE = hash(code + "20200101" + password);
    ```

  - `SIGNATURE_METH`: The method with which the `SIGNATURE` header was generated, `SHA256` is the only supported method at the moment;
  - `Authorization`: A base64 encoded string consisting of the `code` and `password` separated by a colon. That is, `${code}:${password}`.
  - `Content-Type`: This will be `application/json`, since we are sending JSON. The API also supports requests in XML format, but that is out of the scope of this codelab.
  - `Accept`: This will also be `application/json` as we require a JSON response from the server.
  - We create a cipher and decipher using the AES key and IV key provided to us, and use those to decrypt and encrypt futher requests.

### Code sample

```javascript
const crypto = require("crypto");

// Converts a given string to the base64 format
const toBase64 = string => Buffer.from(string).toString("base64");

// Hashes a given string with SHA256
const sha256 = string => {
  const hash = crypto.createHash("sha256");
  hash.update(string);
  return hash.digest("hex");
};

// Takes an AES key and IV key and returns a function that
// encrypts anything it's given using said keys.
const aesEncrypt = (aesKey, ivKey) => text => {
  const cipher = crypto.createCipheriv(
    "aes-128-cbc",
    Buffer.from(aesKey),
    ivKey
  );
  let encrypted = cipher.update(text);
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  return encrypted.toString("hex");
};

// Takes an AES key and IV key and returns a function that
// decrypts anything it's given using said keys.
const aesDecrypt = (aesKey, ivKey) => text => {
  const encryptedText = Buffer.from(text, "hex");
  let decipher = crypto.createDecipheriv(
    "aes-128-cbc",
    Buffer.from(aesKey),
    ivKey
  );
  let decrypted = decipher.update(encryptedText);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  return decrypted.toString();
};

// Returns the date formatted in a YYYYMMDD mode
const getTodaysDate = () =>
  new Date()
    .toJSON()
    .slice(0, 10)
    .replace(/-/g, "");

const API_URL = "https://sandboxapi.fsi.ng/nibss";

function performReset(type = "bvnr") {
  return new Promise((resolve, reject) => {
    fetch(`${API_URL}/${type}/Reset`, {
      method: "POST",
      headers: {
        // Make a request to generate our encryption keys
        OrganisationCode: toBase64(organisationCode),
        "Sandbox-Key": sandboxKey
      }
    })
      .then(res => {
        if (res.status === 200) {
          const header = name => res.headers.get(name);
          const details = {
            name: header("name"),
            ivKey: header("ivkey"),
            aesKey: header("aes_key"),
            password: header("password"),
            email: header("email"),
            code: header("code"),
            name: header("name")
          };
          // Use the data gotten to get a lot of views
          const getRequestHeaders = () => {
            const headers = {
              OrganisationCode: toBase64(organisationCode),
              "Sandbox-Key": sandboxKey,
              SIGNATURE: sha256(
                details.code + getTodaysDate() + details.password
              ),
              SIGNATURE_METH: "SHA256",
              Authorization: toBase64(`${details.code}:${details.password}`),
              "Content-Type": "application/json",
              Accept: "application/json"
            };
            return headers;
          };
          // Create functions for encrypting and decrypting using those details
          const encryptBody = aesEncrypt(details.aesKey, details.ivKey);
          const decryptBody = aesDecrypt(details.aesKey, details.ivKey);
          const credentials = {
            details,
            getRequestHeaders,
            encryptBody,
            decryptBody
          };
          resolve(credentials);
        } else {
          res.text().then(res => {
            reject(res);
          });
        }
      })
      .catch(err => {
        reject(err);
      });
  });
}
```
